好的，架构师。我们来一起梳理一下“手工编辑计划”这个功能的业务逻辑。

根据您的需求，目标是在前端增加一个手工编辑计划的功能，允许用户在计划生成后进行修改，保存后能在页面上看到更新，并可以重复编辑，最终确认无误后点击“开始研究”来执行。

我已经检查了您提供的相关代码文件 (`nodes.py`, `builder.py`, `app.py`, `types.py`, `message-list-view.tsx`, `store.ts`)。这个功能的核心逻辑已经基本实现，主要涉及前端UI交互、后端API通信和图（Graph）状态流转。

### 业务逻辑梳理

整个业务流程可以分为以下几个步骤：

1.  **计划生成与呈现**：
    *   用户提交需求后，后端的`Planner`节点生成一个初步的执行计划。
    *   工作流在`human_feedback_node`节点暂停，并通过`app.py`中的`chat_stream`接口向前端发送一个中断（interrupt）事件。
    *   这个事件包含了计划内容和一组操作选项，如 `["手工编辑计划", "系统自动编辑", "开始研究"]`。

2.  **用户选择手工编辑**：
    *   前端的`PlanCard`组件收到计划和操作选项，并渲染出对应的按钮。
    *   当用户点击【手工编辑计划】按钮时，前端UI切换到编辑模式，允许用户修改计划的标题、思路和具体步骤。

3.  **保存并提交修改**：
    *   用户编辑完成后，点击【保存修改】。
    *   前端 (`message-list-view.tsx`中的`handleSaveEditedPlan`函数) 将修改后的计划打包成一个JSON字符串。
    *   然后调用`sendMessage`函数，通过`interruptFeedback`参数将一个带有特殊标记 `[MANUAL_EDIT]` 和计划JSON的字符串发送给后端。

4.  **后端处理修改**：
    *   后端`human_feedback_node`接收到这个带有`[MANUAL_EDIT]`标记的反馈。
    *   根据这个标记，它将工作流导向一个专门处理手工编辑的节点：`manual_plan_editor_node`。
    *   `manual_plan_editor_node`负责解析、验证前端传来的JSON数据，并用它更新工作流状态（`State`）中的`current_plan`。

5.  **循环反馈与再次编辑**：
    *   `manual_plan_editor_node`处理完成后，**关键的一步**是它会把工作流重新导向回`human_feedback_node`。
    *   `human_feedback_node`再次执行，它会读取到刚刚被更新的计划，然后再次中断，把**更新后**的计划和同样的操作按钮发回给前端。
    *   这样就形成了一个闭环：前端接收新计划 -> 渲染 -> 用户可以再次选择【手工编辑计划】进行修改，或者选择【开始研究】。

6.  **执行计划**：
    *   当用户对修改后的计划满意，点击【开始研究】按钮时。
    *   前端会发送一个值为`"accepted"`的`interruptFeedback`。
    *   `human_feedback_node`接收到这个反馈后，不再中断，而是将工作流推向后续的`research_team`节点，开始执行最终确认的计划。

这个设计是合理的，它将手工编辑和自动编辑的逻辑解耦，并通过状态回环实现了多次编辑的功能，完全符合您的需求。

### 关键代码定位

以下是实现上述逻辑的核心代码片段：

*   **`src/server/app.py`**: 后端入口，负责传递中断信号和选项。
    *   `_astream_workflow_generator`函数中定义了提供给前端的选项，包括`manual_edit_plan`。

*   **`web/src/app/chat/components/message-list-view.tsx`**: 前端UI组件，负责渲染计划和处理编辑交互。
    *   `PlanCard`组件：根据`isEditing`状态来切换显示模式和编辑模式。
    *   `handleSaveEditedPlan`函数：用户点击保存时，构建带有`[MANUAL_EDIT]`标记的反馈信息。
    *   按钮`onClick`事件：处理【手工编辑计划】 (`setIsEditing(true)`) 和【开始研究】 (`handleAccept`) 的点击。

*   **`src/graph/nodes.py`**: 后端图（Graph）的核心节点逻辑。
    *   `human_feedback_node`: 识别`[MANUAL_EDIT]`和`[ACCEPTED]`等不同的用户反馈，并决定下一步的流转方向。
    *   `manual_plan_editor_node`: 新增的节点，专门用于解析和保存用户手工编辑的计划，处理完后将流程导回`human_feedback_node`。

*   **`src/graph/builder.py`**: 图的构建文件。
    *   `_build_base_graph`函数：在这里添加了`manual_plan_editor_node`节点，并定义了它到`human_feedback_node`的边，完成了逻辑闭环。

### 业务逻辑流程图

为了更直观地展示这个流程，我为您绘制了以下的Mermaid时序图：


Ran tool
好的，我已经完成了对“手工编辑计划”功能的业务逻辑梳理、关键代码定位，并通过Mermaid图清晰地展示了整个交互流程。

目前的实现已经相当完善，很好地支持了您提出的需求。如果您确认这套逻辑没有问题，我们可以继续下一步工作。如果您希望对现有逻辑进行调整或有其他问题，请随时提出。