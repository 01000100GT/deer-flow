根据您的需求，我将提供完整的代码修改方案，让用户可以选择手工修改计划还是系统自动修改计划。

## 修改概览

您需要修改以下文件来实现手工编辑计划的功能：

1. **后端工作流节点** - `src/graph/nodes.py`
2. **工作流图构建** - `src/graph/builder.py` 
3. **服务器端选项生成** - `src/server/app.py`
4. **前端计划卡组件** - `web/src/app/chat/components/message-list-view.tsx`

## 1. 修改后端反馈处理逻辑

在 [1](#3-0)  中，需要扩展 `human_feedback_node` 函数来支持两种编辑模式：

```python
def human_feedback_node(
    state,
) -> Command[Literal["planner", "research_team", "reporter", "manual_plan_editor", "__end__"]]:
    current_plan = state.get("current_plan", "")
    # check if the plan is auto accepted
    auto_accepted_plan = state.get("auto_accepted_plan", False)
    if not auto_accepted_plan:
        feedback = interrupt("Please Review the Plan.")

        # if the feedback is not accepted, return the planner node
        if feedback and str(feedback).upper().startswith("[EDIT_PLAN]"):
            # 检查是否是手工编辑模式
            if "[MANUAL_EDIT]" in str(feedback).upper():
                return Command(
                    update={
                        "messages": [
                            HumanMessage(content=feedback, name="feedback"),
                        ],
                    },
                    goto="manual_plan_editor",
                )
            else:
                # 系统自动修改模式（现有逻辑）
                return Command(
                    update={
                        "messages": [
                            HumanMessage(content=feedback, name="feedback"),
                        ],
                    },
                    goto="planner",
                )
        elif feedback and str(feedback).upper().startswith("[ACCEPTED]"):
            logger.info("Plan is accepted by user.")
        else:
            raise TypeError(f"Interrupt value of {feedback} is not supported.")
    
    # ... 其余现有代码保持不变
```

同时在同一文件中添加新的手工编辑节点：

```python
def manual_plan_editor_node(
    state,
) -> Command[Literal["human_feedback", "research_team"]]:
    """处理手工编辑的计划"""
    logger.info("Manual plan editor node is running.")
    
    # 从最新消息中提取编辑后的计划数据
    messages = state.get("messages", [])
    if messages:
        last_message = messages[-1]
        if hasattr(last_message, 'content') and last_message.content:
            try:
                # 尝试解析编辑后的计划
                import json
                from src.prompts.planner_model import Plan
                
                # 假设前端发送的格式是 "[MANUAL_EDIT] {plan_json}"
                content = last_message.content
                if content.startswith("[MANUAL_EDIT]"):
                    plan_json = content.replace("[MANUAL_EDIT]", "").strip()
                    edited_plan_data = json.loads(plan_json)
                    edited_plan = Plan.model_validate(edited_plan_data)
                    
                    return Command(
                        update={
                            "current_plan": edited_plan,
                            "messages": [
                                AIMessage(content=f"Plan has been manually edited: {edited_plan.title}", name="manual_plan_editor")
                            ],
                        },
                        goto="human_feedback",
                    )
            except (json.JSONDecodeError, Exception) as e:
                logger.error(f"Failed to parse manually edited plan: {e}")
    
    # 如果解析失败，返回到人工反馈节点
    return Command(goto="human_feedback")
```

## 2. 更新工作流图

在 [2](#3-1)  中，需要添加新节点和导入：

```python
from .nodes import (
    coordinator_node,
    planner_node,
    reporter_node,
    research_team_node,
    researcher_node,
    coder_node,
    human_feedback_node,
    background_investigation_node,
    manual_plan_editor_node,  # 新增导入
)

def _build_base_graph():
    """Build and return the base state graph with all nodes and edges."""
    builder = StateGraph(State)
    builder.add_edge(START, "coordinator")
    builder.add_node("coordinator", coordinator_node)
    builder.add_node("background_investigator", background_investigation_node)
    builder.add_node("planner", planner_node)
    builder.add_node("reporter", reporter_node)
    builder.add_node("research_team", research_team_node)
    builder.add_node("researcher", researcher_node)
    builder.add_node("coder", coder_node)
    builder.add_node("human_feedback", human_feedback_node)
    builder.add_node("manual_plan_editor", manual_plan_editor_node)  # 新增节点
    
    builder.add_edge("background_investigator", "planner")
    builder.add_edge("manual_plan_editor", "human_feedback")  # 新增边连接
    builder.add_conditional_edges(
        "research_team",
        continue_to_running_research_team,
        ["planner", "researcher", "coder"],
    )
    builder.add_edge("reporter", END)
    return builder
```

## 3. 修改服务器端选项生成

在服务器端代码中（通常在 `src/server/app.py` 的中断选项生成部分），需要修改选项：

```python
"options": [
    {"text": "手工编辑计划", "value": "manual_edit_plan"},
    {"text": "系统自动编辑", "value": "auto_edit_plan"}, 
    {"text": "开始研究", "value": "accepted"},
],
```

## 4. 修改前端UI组件

在 [3](#3-2)  中，需要大幅修改 `PlanCard` 组件：

```typescript
function PlanCard({
  className,
  message,
  interruptMessage,
  onFeedback,
  waitForFeedback,
  onSendMessage,
}: {
  className?: string;
  message: Message;
  interruptMessage?: Message | null;
  onFeedback?: (feedback: { option: Option }) => void;
  onSendMessage?: (
    message: string,
    options?: { interruptFeedback?: string },
  ) => void;
  waitForFeedback?: boolean;
}) {
  const [isEditing, setIsEditing] = useState(false);
  const [editedPlan, setEditedPlan] = useState<{
    title?: string;
    thought?: string;
    steps?: { title?: string; description?: string }[];
  }>({});

  const plan = useMemo<{
    title?: string;
    thought?: string;
    steps?: { title?: string; description?: string }[];
  }>(() => {
    return parseJSON(message.content ?? "", {});
  }, [message.content]);

  // 初始化编辑状态
  useEffect(() => {
    setEditedPlan(plan);
  }, [plan]);

  const handleAccept = useCallback(async () => {
    if (onSendMessage) {
      onSendMessage(
        `${GREETINGS[Math.floor(Math.random() * GREETINGS.length)]}! ${Math.random() > 0.5 ? "Let's get started." : "Let's start."}`,
        {
          interruptFeedback: "accepted",
        },
      );
    }
  }, [onSendMessage]);

  const handleSaveEditedPlan = useCallback(async () => {
    if (onSendMessage) {
      const planJson = JSON.stringify(editedPlan);
      onSendMessage(
        `计划已手工修改完成`,
        {
          interruptFeedback: `[MANUAL_EDIT] ${planJson}`,
        },
      );
      setIsEditing(false);
    }
  }, [onSendMessage, editedPlan]);

  const handleCancelEdit = useCallback(() => {
    setEditedPlan(plan);
    setIsEditing(false);
  }, [plan]);

  return (
    <Card className={cn("w-full", className)}>
      <CardHeader>
        <CardTitle>
          {isEditing ? (
            <input
              type="text"
              value={editedPlan.title || ""}
              onChange={(e) => setEditedPlan(prev => ({ ...prev, title: e.target.value }))}
              className="w-full p-2 border rounded"
              placeholder="计划标题"
            />
          ) : (
            <Markdown animated>
              {`### ${
                plan.title !== undefined && plan.title !== ""
                  ? plan.title
                  : "Deep Research"
              }`}
            </Markdown>
          )}
        </CardTitle>
      </CardHeader>
      <CardContent>
        {isEditing ? (
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium mb-2">思路描述</label>
              <textarea
                value={editedPlan.thought || ""}
                onChange={(e) => setEditedPlan(prev => ({ ...prev, thought: e.target.value }))}
                className="w-full p-2 border rounded h-24"
                placeholder="计划思路"
              />
            </div>
            <div>
              <label className="block text-sm font-medium mb-2">执行步骤</label>
              {editedPlan.steps?.map((step, i) => (
                <div key={i} className="mb-4 p-3 border rounded">
                  <input
                    type="text"
                    value={step.title || ""}
                    onChange={(e) => {
                      const newSteps = [...(editedPlan.steps || [])];
                      newSteps[i] = { ...newSteps[i], title: e.target.value };
                      setEditedPlan(prev => ({ ...prev, steps: newSteps }));
                    }}
                    className="w-full p-2 border rounded mb-2"
                    placeholder={`步骤 ${i + 1} 标题`}
                  />
                  <textarea
                    value={step.description || ""}
                    onChange={(e) => {
                      const newSteps = [...(editedPlan.steps || [])];
                      newSteps[i] = { ...newSteps[i], description: e.target.value };
                      setEditedPlan(prev => ({ ...prev, steps: newSteps }));
                    }}
                    className="w-full p-2 border rounded h-20"
                    placeholder={`步骤 ${i + 1} 描述`}
                  />
                </div>
              ))}
            </div>
          </div>
        ) : (
          <>
            <Markdown className="opacity-80" animated>
              {plan.thought}
            </Markdown>
            {plan.steps && (
              <ul className="my-2 flex list-decimal flex-col gap-4 border-l-[2px] pl-8">
                {plan.steps.map((step, i) => (
                  <li key={`step-${i}`}>
                    <h3 className="mb text-lg font-medium">
                      <Markdown animated>{step.title}</Markdown>
                    </h3>
                    <div className="text-muted-foreground text-sm">
                      <Markdown animated>{step.description}</Markdown>
                    </div>
                  </li>
                ))}
              </ul>
            )}
          </>
        )}
      </CardContent>
      <CardFooter className="flex justify-end">
        {isEditing ? (
          <div className="flex gap-2">
            <Button variant="outline" onClick={handleCancelEdit}>
              取消
            </Button>
            <Button onClick={handleSaveEditedPlan}>
              保存修改
            </Button>
          </div>
        ) : (
          !message.isStreaming && interruptMessage?.options?.length && (
            <motion.div
              className="flex gap-2"
              initial={{ opacity: 0, y: 12 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.3, delay: 0.3 }}
            >
              {interruptMessage?.options.map((option) => (
                <Button
                  key={option.value}
                  variant={option.value === "accepted" ? "default" : "outline"}
                  disabled={!waitForFeedback}
                  onClick={() => {
                    if (option.value === "accepted") {
                      void handleAccept();
                    } else if (option.value === "manual_edit_plan") {
                      setIsEditing(true);
                    } else if (option.value === "auto_edit_plan") {
                      onFeedback?.({
                        option: { ...option, value: "edit_plan" },
                      });
                    } else {
                      onFeedback?.({
                        option,
                      });
                    }
                  }}
                >
                  {option.text}
                </Button>
              ))}
            </motion.div>
          )
        )}
      </CardFooter>
    </Card>
  );
}
```

## 数据流总结

完整的数据流程是：
1. 用户在 `PlanCard` 中点击"手工编辑计划"
2. 前端进入编辑模式，显示可编辑表单
3. 用户修改后点击"保存修改"
4. 前端发送 `[MANUAL_EDIT] {plan_json}` 到后端
5. `human_feedback_node` 识别并路由到 `manual_plan_editor_node`
6. `manual_plan_editor_node` 解析并更新计划，返回到 `human_feedback_node`
7. 用户可以最终确认修改后的计划

这个实现提供了完整的手工编辑功能，同时保持了与现有系统的兼容性。

Wiki pages you might want to explore:
- [System Architecture (bytedance/deer-flow)](/wiki/bytedance/deer-flow#2)
- [Multi-Agent Workflow (bytedance/deer-flow)](/wiki/bytedance/deer-flow#2.1)